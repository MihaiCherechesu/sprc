/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "api.hpp"

bool_t
xdr_err_type (XDR *xdrs, err_type *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_op_type (XDR *xdrs, op_type *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_stat_type (XDR *xdrs, stat_type *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_msg_type_ (XDR *xdrs, msg_type_ *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_sensor_data (XDR *xdrs, sensor_data *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->sensor_id))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->values.values_val, (u_int *) &objp->values.values_len, ~0,
		sizeof (float), (xdrproc_t) xdr_float))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_sensor_stats (XDR *xdrs, sensor_stats *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->sensor_id))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->stats.stats_val, (u_int *) &objp->stats.stats_len, 4,
		sizeof (float), (xdrproc_t) xdr_float))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_req_login (XDR *xdrs, req_login *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->username, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_req_logout (XDR *xdrs, req_logout *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->filler))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_req_load (XDR *xdrs, req_load *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->sdl.sdl_val, (u_int *) &objp->sdl.sdl_len, ~0,
		sizeof (sensor_data), (xdrproc_t) xdr_sensor_data))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_req_store (XDR *xdrs, req_store *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->filler))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_req_add (XDR *xdrs, req_add *objp)
{
	register int32_t *buf;

	 if (!xdr_sensor_data (xdrs, &objp->sd))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_req_del (XDR *xdrs, req_del *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->sensor_id))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_req_update (XDR *xdrs, req_update *objp)
{
	register int32_t *buf;

	 if (!xdr_sensor_data (xdrs, &objp->sd))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_req_read (XDR *xdrs, req_read *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->sensor_id))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_req_get_stat (XDR *xdrs, req_get_stat *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->sensor_id))
		 return FALSE;
	 if (!xdr_stat_type (xdrs, &objp->s_type))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_req_get_stat_all (XDR *xdrs, req_get_stat_all *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->filler))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_rpc_request_body (XDR *xdrs, rpc_request_body *objp)
{
	register int32_t *buf;

	 if (!xdr_op_type (xdrs, &objp->op))
		 return FALSE;
	switch (objp->op) {
	case LOGIN:
		 if (!xdr_req_login (xdrs, &objp->rpc_request_body_u.r0))
			 return FALSE;
		break;
	case LOGOUT:
		 if (!xdr_req_logout (xdrs, &objp->rpc_request_body_u.r1))
			 return FALSE;
		break;
	case LOAD:
		 if (!xdr_req_load (xdrs, &objp->rpc_request_body_u.r2))
			 return FALSE;
		break;
	case STORE:
		 if (!xdr_req_store (xdrs, &objp->rpc_request_body_u.r3))
			 return FALSE;
		break;
	case ADD:
		 if (!xdr_req_add (xdrs, &objp->rpc_request_body_u.r4))
			 return FALSE;
		break;
	case DEL:
		 if (!xdr_req_del (xdrs, &objp->rpc_request_body_u.r5))
			 return FALSE;
		break;
	case UPDATE:
		 if (!xdr_req_update (xdrs, &objp->rpc_request_body_u.r6))
			 return FALSE;
		break;
	case READ:
		 if (!xdr_req_read (xdrs, &objp->rpc_request_body_u.r7))
			 return FALSE;
		break;
	case GET_STAT:
		 if (!xdr_req_get_stat (xdrs, &objp->rpc_request_body_u.r8))
			 return FALSE;
		break;
	case GET_STAT_ALL:
		 if (!xdr_req_get_stat_all (xdrs, &objp->rpc_request_body_u.r9))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_rpc_request (XDR *xdrs, rpc_request *objp)
{
	register int32_t *buf;

	 if (!xdr_u_long (xdrs, &objp->session_key))
		 return FALSE;
	 if (!xdr_rpc_request_body (xdrs, &objp->body))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_repl_login (XDR *xdrs, repl_login *objp)
{
	register int32_t *buf;

	 if (!xdr_u_long (xdrs, &objp->new_session_key))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_repl_logout (XDR *xdrs, repl_logout *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->filler))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_repl_load (XDR *xdrs, repl_load *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->filler))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_repl_store (XDR *xdrs, repl_store *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->sdl.sdl_val, (u_int *) &objp->sdl.sdl_len, ~0,
		sizeof (sensor_data), (xdrproc_t) xdr_sensor_data))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_repl_add (XDR *xdrs, repl_add *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->filler))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_repl_del (XDR *xdrs, repl_del *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->filler))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_repl_update (XDR *xdrs, repl_update *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->filler))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_repl_read (XDR *xdrs, repl_read *objp)
{
	register int32_t *buf;

	 if (!xdr_sensor_data (xdrs, &objp->sd))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_repl_get_stat (XDR *xdrs, repl_get_stat *objp)
{
	register int32_t *buf;

	 if (!xdr_float (xdrs, &objp->stat))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_repl_get_stat_all (XDR *xdrs, repl_get_stat_all *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->ssl.ssl_val, (u_int *) &objp->ssl.ssl_len, ~0,
		sizeof (sensor_stats), (xdrproc_t) xdr_sensor_stats))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_rpc_reply_body (XDR *xdrs, rpc_reply_body *objp)
{
	register int32_t *buf;

	 if (!xdr_op_type (xdrs, &objp->op))
		 return FALSE;
	switch (objp->op) {
	case LOGIN:
		 if (!xdr_repl_login (xdrs, &objp->rpc_reply_body_u.r0))
			 return FALSE;
		break;
	case LOGOUT:
		 if (!xdr_repl_logout (xdrs, &objp->rpc_reply_body_u.r1))
			 return FALSE;
		break;
	case LOAD:
		 if (!xdr_repl_load (xdrs, &objp->rpc_reply_body_u.r2))
			 return FALSE;
		break;
	case STORE:
		 if (!xdr_repl_store (xdrs, &objp->rpc_reply_body_u.r3))
			 return FALSE;
		break;
	case ADD:
		 if (!xdr_repl_add (xdrs, &objp->rpc_reply_body_u.r4))
			 return FALSE;
		break;
	case DEL:
		 if (!xdr_repl_del (xdrs, &objp->rpc_reply_body_u.r5))
			 return FALSE;
		break;
	case UPDATE:
		 if (!xdr_repl_update (xdrs, &objp->rpc_reply_body_u.r6))
			 return FALSE;
		break;
	case READ:
		 if (!xdr_repl_read (xdrs, &objp->rpc_reply_body_u.r7))
			 return FALSE;
		break;
	case GET_STAT:
		 if (!xdr_repl_get_stat (xdrs, &objp->rpc_reply_body_u.r8))
			 return FALSE;
		break;
	case GET_STAT_ALL:
		 if (!xdr_repl_get_stat_all (xdrs, &objp->rpc_reply_body_u.r9))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_rpc_reply (XDR *xdrs, rpc_reply *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->success_message, ~0))
		 return FALSE;
	 if (!xdr_rpc_reply_body (xdrs, &objp->body))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_rpc_success (XDR *xdrs, rpc_success *objp)
{
	register int32_t *buf;

	 if (!xdr_msg_type_ (xdrs, &objp->m_type))
		 return FALSE;
	switch (objp->m_type) {
	case REQ:
		 if (!xdr_rpc_request (xdrs, &objp->rpc_success_u.req))
			 return FALSE;
		break;
	case REPL:
		 if (!xdr_rpc_reply (xdrs, &objp->rpc_success_u.repl))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_rpc_failure (XDR *xdrs, rpc_failure *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->failure_message, ~0))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->failure_code))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_rpc_msg_ (XDR *xdrs, rpc_msg_ *objp)
{
	register int32_t *buf;

	 if (!xdr_err_type (xdrs, &objp->err))
		 return FALSE;
	switch (objp->err) {
	case SUCC:
		 if (!xdr_rpc_success (xdrs, &objp->rpc_msg__u.success))
			 return FALSE;
		break;
	case FAIL:
		 if (!xdr_rpc_failure (xdrs, &objp->rpc_msg__u.failure))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}
